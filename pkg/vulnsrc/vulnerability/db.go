package vulnerability

import (
	"encoding/json"

	"github.com/aquasecurity/trivy/pkg/db"
	bolt "github.com/etcd-io/bbolt"
	"golang.org/x/xerrors"
)

const (
	rootBucket = "vulnerability"
)

type Operations interface {
	Put(*bolt.Tx, string, string, Vulnerability) error
	Update(string, string, Vulnerability) error
	BatchUpdate(func(bucket *bolt.Bucket) error) error
	Get(string) (map[string]Vulnerability, error)
}

type DB struct {
}

func (d DB) Put(tx *bolt.Tx, cveID, source string, vuln Vulnerability) error {
	root, err := tx.CreateBucketIfNotExists([]byte(rootBucket))
	if err != nil {
		return err
	}
	return db.Put(root, cveID, source, vuln)
}

func (d DB) Update(cveID, source string, vuln Vulnerability) error {
	return db.Config{}.Update(rootBucket, cveID, source, vuln)
}

func (d DB) BatchUpdate(fn func(b *bolt.Bucket) error) error {
	return db.Config{}.BatchUpdate(func(tx *bolt.Tx) error {
		root, err := tx.CreateBucketIfNotExists([]byte(rootBucket))
		if err != nil {
			return err
		}
		return fn(root)
	})
}

func (d DB) Get(cveID string) (map[string]Vulnerability, error) {
	values, err := db.Config{}.ForEach(rootBucket, cveID)
	if err != nil {
		return nil, xerrors.Errorf("error in NVD get: %w", err)
	}
	if len(values) == 0 {
		return nil, nil
	}

	vulns := map[string]Vulnerability{}
	for source, value := range values {
		var vuln Vulnerability
		if err = json.Unmarshal(value, &vuln); err != nil {
			return nil, xerrors.Errorf("failed to unmarshal Vulnerability JSON: %w", err)
		}
		vulns[source] = vuln
	}
	return vulns, nil
}
